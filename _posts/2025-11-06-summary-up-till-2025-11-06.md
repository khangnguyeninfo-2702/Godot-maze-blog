---
layout: post
title: "Devlog #2: UI Foundations, Physics, and the Dashing Wall Smash"
date: 2025-11-06 17:22:00
categories: [godot, programming, devblog, ui, physics]
---

## üé® Phase 1: Building the Main Menu UI (Nov 4th)

I kicked off the week by implementing the main menu and establishing the basic flow of the game. This was primarily a UI day, focusing on getting the game's presentation right.

### The UI Toolkit: Containers and Texture Buttons

I started by integrating a neat pixel art UI set I found online. This introduced me to the necessary tools for complex UI layouts in Godot:

* **`TextureButton` Nodes:** Learning how to crop a spritesheet and set the different `hover`, `pressed`, and `normal` states for the button images.
* **Containers (`VBox`, `HBox`, `CenterContainer`):** These are essential for managing button layout and order.

### Problem Breakdown: The Layout Wars

My biggest battle was with the containers themselves. While they simplify layout, they initially limited my creative freedom:

1.  **Missing Assets:** The downloaded spritesheet didn't have the text I needed (like "Start" or "Play").
    * **Solution:** I improvised using a basic image editor (Paint) to separate letters and stick them onto the existing blank buttons.
2.  **Rigid Positioning:** I couldn't position buttons freely; they all moved uniformly with the parent container.
    * **Solution:** This required building a **complex nested container structure** (containers within containers). While complex to look at in the Scene Tree, it gave me the granular control I needed to position clusters of elements exactly where I wanted them.
3.  **Scaling Issues:** Containers kept resetting my button sizes.
    * **Solution:** I dove into the Godot docs and found that by adjusting the button's **`Rect -> Size Flags`** and tweaking the **`Custom Minimum Size`** properties, I could force the containers to respect my desired dimensions.

### Background and Score

To finalize the environment, I created a procedural, space-like background where pixelated squares and triangles float around and bounce against each other, using basic physics.

* **Physics Gotcha:** The initial spawn points were all clustered at the origin (0, 0).
* **Fix:** Using `call_deferred` to set the block's position **before** adding them as a child of the background was the key to ensuring the position was calculated correctly and they scattered randomly across the screen.
* I also integrated the score screen and created the logic for **ascending to progressively larger maze levels**.

---

## üí• Phase 2: Core Combat and Movement (Nov 5th)

The next day was all about new mechanics, specifically destructive capabilities and player mobility.

### Landmines and Walls

I upgraded the landmines to not just damage the player, but to also damage and potentially destroy the maze **walls**.

* **Learned:** This was easily implemented by leveraging my existing **Health Component** and attaching it directly to the wall tiles. Now, walls can take damage, track their health, and trigger a "death" function.

### The Dashing Wall Smash

I added a **dashing ability** triggered by the "Shift" key, which dramatically increased mobility. The tricky part was creating a realistic punishment: **knockback** if the player dashes head-on into a wall.

* **Problem:** Determining what constitutes a "head-on collision." Initially, any contact with a wall (side or front) resulted in a knockback, which felt unfair.
* **Solution:** I needed to compare the player's **movement direction** with the **collision normal** (the direction the wall is facing). By calculating the **dot product** of these two vectors, I could determine the angle. If the result was close to `1` (meaning the vectors are perfectly aligned), it was a true head-on collision, and the player deserved the knockback!

---

## ‚è±Ô∏è Phase 3: Improving User Experience (Nov 6th)

Today, I focused on visual polish, specifically implementing a **skill cooldown indicator** to improve player feedback.

* **Learned:** I focused on the **`TextureProgressBar`** node, which is incredibly versatile for visual meters.
* **Problem:** I wanted the cooldown to visually sweep around the progress bar like a clock, but it defaulted to a horizontal fill.
* **Solution:** This was a simple fix, but a surprising one: I just needed to change the `TextureProgressBar`'s **`Fill Mode`** property to **`Clockwise`** to achieve the desired radial, cooldown animation.

I'm now diving into the art side, learning basic **pixel art drawing and color theory** to make these UI elements really pop. It's a fun challenge trying to draw with only a mouse and no draw pad, but I'll keep experimenting!

## üé¨ Next Steps

With the fundamentals working, I'll be looking at enhancing the player experience even further probably by drawing some more stuffs like cracked walls, abilities emojis... 